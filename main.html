<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>怪文書ジェネレーター</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho+B1:wght@700&family=Yusei+Magic&family=Zen+Maru+Gothic:wght@900&family=Mochiy+Pop+One&family=Kosugi+Maru&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #1a202c;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
    }
    
    .paper-container {
      border: none;
      transform: rotate(0);
      filter: none;
      background-color: transparent;
    }

    #generator-canvas {
      background-color: #fff8e1;
    }

    .btn-style {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.2s;
    }
    .btn-style:hover {
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
      transform: translateY(-2px);
    }
    .btn-style:active {
      transform: translateY(1px);
    }
    
  </style>
</head>
<body class="font-sans">
  <div class="container mx-auto max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 text-center space-y-6">
    <h1 class="text-3xl font-extrabold text-white tracking-tight">
      怪文書ジェネレーター
    </h1>

    <div id="canvas-container" class="relative w-full flex justify-center items-center rounded-lg overflow-hidden shadow-inner paper-container">
      <canvas id="generator-canvas" width="600" height="400"></canvas>
    </div>

    <div class="space-y-4">
      <div>
        <label for="upperText" class="block text-left text-sm font-bold text-gray-300 mb-1">上段のテキスト</label>
        <input type="text" id="upperText" value="明日、正午" class="w-full px-4 py-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg">
      </div>
      <div>
        <label for="lowerText" class="block text-left text-sm font-bold text-gray-300 mb-1">下段のテキスト</label>
        <input type="text" id="lowerText" value="港の倉庫に来い" class="w-full px-4 py-2 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg">
      </div>
    </div>
    
    <div class="space-y-2 mt-4 text-left">
      <span class="text-sm font-bold text-gray-300">使用するフォントを選択してください:</span>
      <div id="font-checkboxes" class="flex flex-wrap gap-4 mt-2">
      </div>
    </div>

    <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 justify-center">
        <button id="regenerate-appearance-button" class="w-full sm:w-auto px-8 py-4 bg-yellow-400 text-black font-bold text-xl rounded-lg btn-style focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50">
            🎨 見た目を再生成
        </button>
        <button id="save-button" class="w-full sm:w-auto px-8 py-4 bg-red-600 text-white font-bold text-xl rounded-lg btn-style focus:outline-none focus:ring-4 focus:ring-red-600 focus:ring-opacity-50">
            画像を保存
        </button>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('generator-canvas');
      const ctx = canvas.getContext('2d');
      const upperTextInput = document.getElementById('upperText');
      const lowerTextInput = document.getElementById('lowerText');
      const saveButton = document.getElementById('save-button');
      const regenerateAppearanceButton = document.getElementById('regenerate-appearance-button');
      const fontCheckboxesContainer = document.getElementById('font-checkboxes');
      
      const allFonts = [
        { name: 'Shippori Mincho B1', weight: '700', size: 70, label: '明朝' },
        { name: 'Yusei Magic', weight: 'normal', size: 68, label: '優雅' },
        { name: 'Zen Maru Gothic', weight: '900', size: 75, label: '丸字' },
        { name: 'Mochiy Pop One', weight: 'normal', size: 70, label: 'ポップ' },
        { name: 'Kosugi Maru', weight: 'normal', size: 72, label: 'ゴシック' }
      ];

      const backgroundColors = [
        '#FFFFFF',
        '#E0E0E0',
        '#CCCCCC',
        '#000000',
      ];

      let fixedColorsUpper = null;
      let fixedColorsLower = null;
      
      allFonts.forEach((font, index) => {
        const checkboxDiv = document.createElement('div');
        checkboxDiv.className = 'flex items-center';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `font-checkbox-${index}`;
        checkbox.className = 'form-checkbox h-5 w-5 text-purple-600';
        checkbox.checked = true;
        
        const label = document.createElement('label');
        label.htmlFor = `font-checkbox-${index}`;
        label.className = 'ml-2 text-white cursor-pointer';
        label.textContent = font.label;
        label.style.fontFamily = `'${font.name}', sans-serif`;
        
        checkboxDiv.appendChild(checkbox);
        checkboxDiv.appendChild(label);
        fontCheckboxesContainer.appendChild(checkboxDiv);
        
        checkbox.addEventListener('change', () => {
          drawCanvas();
        });
      });

      const getSelectedFonts = () => {
        const selectedFonts = [];
        const checkboxes = fontCheckboxesContainer.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach((checkbox, index) => {
          if (checkbox.checked) {
            selectedFonts.push(allFonts[index]);
          }
        });
        return selectedFonts.length > 0 ? selectedFonts : allFonts;
      };

      const getBackgroundColor = (avoidColor = null) => {
        let newColor;
        do {
          const randomIndex = Math.floor(Math.random() * backgroundColors.length);
          newColor = backgroundColors[randomIndex];
        } while (newColor === avoidColor);
        return newColor;
      };
      
      const drawWarning = (message) => {
        ctx.fillStyle = '#fff8e1';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#FF0000';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
      };

      const drawText = (text, yPos, bgColors) => {
        if (!text) return;
        
        const maxWidth = canvas.width - 60;
        const regularPadding = 8;
        const smallCharPadding = 1;
        const spacing = 10;
        const selectedFonts = getSelectedFonts();
        const spaceWidth = 20;
        
        let charData = [];
        let totalTextWidth = 0;
        let fontSizeMultiplier = 1;
        
        const isSmallCharacter = (char) => {
          return ['、', '。', '！', '？', '・'].includes(char);
        };

        text.split('').forEach((char, index) => {
          if (char === ' ' || char === '　') {
            charData.push({ isSpace: true, width: spaceWidth });
            totalTextWidth += spaceWidth + spacing;
          } else {
            const font = selectedFonts[index % selectedFonts.length];
            
            const padding = isSmallCharacter(char) ? smallCharPadding : regularPadding;
            const bgColor = bgColors[index];
            const size = font.size;
            ctx.font = `${font.weight} ${size}px "${font.name}"`;
            const textMetrics = ctx.measureText(char);
            const textWidth = textMetrics.width;
            const bgWidth = textWidth + padding * 2;
            const bgHeight = size + padding * 2;
            charData.push({ char, font, size, textWidth, bgWidth, bgColor, isSpace: false, width: bgWidth, bgHeight });
            totalTextWidth += bgWidth + spacing;
          }
        });
        
        if (charData.length > 0) {
            totalTextWidth -= spacing;
        }

        if (totalTextWidth > maxWidth) {
          fontSizeMultiplier = maxWidth / totalTextWidth;
        }

        let currentPos = (canvas.width - totalTextWidth * fontSizeMultiplier) / 2;

        for (let i = 0; i < charData.length; i++) {
          const charInfo = charData[i];
          const adjustedWidth = charInfo.width * fontSizeMultiplier;

          if (charInfo.isSpace) {
            currentPos += adjustedWidth + spacing * fontSizeMultiplier;
            continue;
          }

          const { char, font, size, bgWidth, bgColor, bgHeight } = charInfo;
          
          const adjustedFontSize = size * fontSizeMultiplier;
          ctx.font = `${font.weight} ${adjustedFontSize}px "${font.name}"`;
          const adjustedBgWidth = bgWidth * fontSizeMultiplier;
          const adjustedBgHeight = bgHeight * fontSizeMultiplier;
          
          const charCenterX = currentPos + adjustedBgWidth / 2;
          
          const randomRotation = (Math.random() - 0.5) * 0.8;
          const randomYOffset = (Math.random() - 0.5) * 15;

          ctx.save();
          
          ctx.translate(charCenterX, yPos + randomYOffset);
          
          ctx.rotate(randomRotation);
          
          ctx.fillStyle = bgColor;
          const bgX = -adjustedBgWidth / 2;
          const bgY = -adjustedBgHeight / 2;
          ctx.fillRect(bgX, bgY, adjustedBgWidth, adjustedBgHeight);
          
          ctx.fillStyle = bgColor === '#000000' ? '#FFFFFF' : '#000000';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(char, 0, 0);

          ctx.restore();
          
          currentPos += adjustedBgWidth + spacing * fontSizeMultiplier;
        }
      };

      const drawCanvas = () => {
        const selectedFonts = getSelectedFonts();
        if (selectedFonts.length < 2) {
          drawWarning("フォントは2つ以上選択してください");
          return;
        }
        
        ctx.fillStyle = '#fff8e1';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!fixedColorsUpper) {
            fixedColorsUpper = upperTextInput.value.split('').map(() => getBackgroundColor());
        }
        if (!fixedColorsLower) {
            fixedColorsLower = lowerTextInput.value.split('').map((_, index) => {
                return getBackgroundColor(fixedColorsUpper[index % fixedColorsUpper.length]);
            });
        }
        drawText(upperTextInput.value, canvas.height / 2 - 50, fixedColorsUpper);
        drawText(lowerTextInput.value, canvas.height / 2 + 50, fixedColorsLower);
      };

      upperTextInput.addEventListener('input', () => {
        fixedColorsUpper = null;
        fixedColorsLower = null;
        drawCanvas();
      });
      lowerTextInput.addEventListener('input', () => {
        fixedColorsUpper = null;
        fixedColorsLower = null;
        drawCanvas();
      });

      drawCanvas();

      regenerateAppearanceButton.addEventListener('click', () => {
        fixedColorsUpper = null;
        fixedColorsLower = null;
        drawCanvas();
      });

      saveButton.addEventListener('click', () => {
        const selectedFonts = getSelectedFonts();
        if (selectedFonts.length < 2) {
          drawWarning("フォントは2つ以上選択してください");
          return;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawText(upperTextInput.value, canvas.height / 2 - 50, fixedColorsUpper);
        drawText(lowerTextInput.value, canvas.height / 2 + 50, fixedColorsLower);
        
        const imageURL = canvas.toDataURL('image/png');
        
        ctx.fillStyle = '#fff8e1';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawText(upperTextInput.value, canvas.height / 2 - 50, fixedColorsUpper);
        drawText(lowerTextInput.value, canvas.height / 2 + 50, fixedColorsLower);
        
        const link = document.createElement('a');
        link.href = imageURL;
        link.download = 'kaibunsho.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });
    });
  </script>
</body>
</html>
